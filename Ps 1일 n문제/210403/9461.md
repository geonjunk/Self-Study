# 문제 : 백준 9461번 - 파도반 수열
* 링크 : https://www.acmicpc.net/problem/9461

## 풀이
* 나열을 통해 점화식 유도하는 Dp문제
* 나선 모양으로 처음부터 나열해보면 
    * 1 1 1 2 3 3 4 5 7 9 12..
    * 6번째부터 규칙 구하면 3=1+2 , 4=1+3,5=1+4....
    * 즉, 바로이전 값 +5번째 전 값을 더하면 현재 값이 나오는 형태임을 알수 있음
    * 따라서 P(N)=P(N-1)+P(N-5)의 점화식을 갖는다
* P(N)의 값 저장하는 배열 dp라하고 dp[5]까지는 초기값 넣어주고 점화식을 이용해 bottom-up방식으로 dp(n) 구한다
* n의 최댓값 입력했을 때 int형의 범위 넘어가므로 long이상의 type의 배열 이용한다
* 테스트 케이스의 개수가 여러개 일 수도 있으므로 반복 줄이기 위해 이전의 실행했던 테스트케이스의 dp값을 이용해주는 방법도 사용가능하다
* 코드)
```
#include<iostream>
using namespace std;

int main() {
	int t, n,pre;
	cin >> t;
	long dp[101] = { 0, };
	dp[1] = dp[2]=dp[3]=1;
	dp[4] = 2;
	pre = 4;
	while (t > 0) {
		cin >> n;
		if (n > pre) {
			for (int i = pre+1; i <= n; i++) {
				dp[i] = dp[i - 1] + dp[i - 5];
			}
			pre = n;
		}
		cout << dp[n] << "\n";
		t--;
	}

	return 0;
}
// 초과 판단법 : 마지막 수 입력 해보기
// 횟수 줄이는 법 -> 이전 수 기억해놓음
```

## 리뷰
* 자료형 선정 법 : 결과값의 최댓값이 어떤 범위에 있는지 체크한다
* 이전 수를 기억해놓음을 통해 반복 수 줄이는 방법도 기억해두기!
