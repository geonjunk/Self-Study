# 문제 : 9465번 - 스티커

* 링크 : https://www.acmicpc.net/problem/9465



## 풀이

* 계단오르기와 비슷하지만 좀 더 생각이 필요한 dp문제

* 2차원 배열 arr을 정의하는데 arr[i] [j]은 i행 j열의 스티커 점수

* 2차원 배열 dp를 정의하는데 dp[i] [j] 는 i행 j열의 스티커 점수의 최댓값

* 스티커 붙이려면 가로, 세로, 위, 아래 위치에 스티커 있으면 안되기 때문에 대각선만 가능한데, 바로 전 대각선 뿐만 아니라 두칸, 세칸.. 그 이상의 칸 다음의 대각선으로도 이동가능하다

* 이때 3칸 뒤 대각선의 경우는 결국 1칸의 대각선+2칸의 대각선으로도 갈 수 있으므로 3칸 이상의 대각선이동은 최대값이 될 수 없다 

* 따라서 1칸, 2칸 대각선 뒤만 고려하면 된다

* x행에 y열위치에 스티커 붙일때 그 이전단계에 스티커 붙일 수 위치를 생각해보면

  * x=1일때 : 2행  y-1열, 2행 y-2열
  * x=2일때 : 1행 y-1 열, 1행 y-2열

* 2차원 배열 dp를 정의하고 이를 이용해 점화식 세우면

  * 1행 일때 : dp[0] [k] =max(dp[1] [k-2],dp[1] [k-1])+arr[0] [k]
  * 2행 일때 : dp[1] [k] = max(dp[0] [k-2],dp[0] [k-1])+arr[1] [k]

* 코드)

  ```c++
  #include<iostream>
  #include<algorithm>
  using namespace std;
  
  int arr[2][100001];
  int dp[2][100001];
  int main() {
  	int T,n;
  	cin >> T;
  	while (T > 0) {
  		cin >> n;
  		
  		for (int i = 0; i < 2; i++) {
  			for (int j = 1; j <= n; j++) {
  				cin >> arr[i][j];
  			}
  		}
  		dp[0][1] = arr[0][1];
  		dp[1][1] = arr[1][1];
  		for (int i = 2; i <= n; i++) {
  			dp[0][i] = max(dp[1][i - 2], dp[1][i - 1])+arr[0][i];
  			dp[1][i] = max(dp[0][i - 2], dp[0][i - 1]) + arr[1][i];
  		}
  		cout << max(dp[0][n], dp[1][n])<<"\n";
  		T--;
  	}
  
  
  
  	return 0;
  }
  ```



## 리뷰

* dp를 구현할때 계단오르기 같은 유형은 항상 이전 case가 어떤 case가 있는지 논리적으로 생각해보기