# 백준 2839번 - 설탕배달
## 문제 

	![](./2839.png)
 
* 문제 해석
    * 설탕 무게 N을 입력받고 3킬로 봉지와 5킬로 봉지를 통해 설탕을 담아 최소의 봉지의 개수를 구하는 문제로 2가지 종류의 봉지로 담았을때 다 담을 수 있으면(나누어 떨어지면) 최소의 봉지 개수를 출력하고 나누어 떨어지지 않으면 -1을 출력한다

## 풀이 
1. 동적 계획법(DP) 이용
    * 배열 sugar를 정의하는데 sugar[k]는 k킬로의 설탕을 담는데 필요한 봉지의 개수이다
    * 결과 값인 sugar[n]을 구하기 위해서 이전 값을 이용하는데 이는 sugar[n-3]과 sugar[n-5]의 값중 최솟값에 하나의 봉지를 더 사용했기 때문에 +1을 한 값이다
    * 즉, sugar[n]= min(sugar[n-3],sugar[n-5])+1
    * 최솟값을 이용하기 때문에 담을 수 없는 설탕의 무게는 매우 큰 수로 저장하고 sugar[3]과 sugar[5]는 기본값인 1로 저장한다
    * 이 사실들을 이용해 bottom-up방식으로 sugar[n]값을 구한다
    * 코드
    ```
    int main() {
	int sugar[5001];
	int n;
	cin >> n;
	for (int i = 0; i <=n; i++) {
		sugar[i] = 9999;
	}
	sugar[3] = sugar[5] = 1;
	for (int i = 6; i <= n; i++) {
		sugar[i] = min(sugar[i - 3], sugar[i - 5]) + 1;
	}
	if (sugar[n] >= 9999) cout << -1 << "\n";
	else cout << sugar[n] << "\n";

	return 0;
    }
    ```
    * 접근 법 
        * 처음에는 i-3, i-5 인덱스 만 이용하지 않고 모든 경우의 수 이용하였으면 나누어 떨어지지 않는 index에는 -1 넣어서 i값 구함, 이는 if문이 추가로 필요했으며 min 연산이 불가능해짐
        * 이후에는 i-3 i-5만 이용하면 됨을 깨달았고 나누어 떨어지지 않는 인덱스에는 매우 큰 값 넣어 min연산이 가능해졌음
2. 수식 이용
    * 5킬로 봉지를 최대한 많이 이용할수록 봉지의 개수는 줄어들 것이다
    * 따라서 주어진 n값에서 5로 나누어 떨어지는지 확인을 한 후 나누어 떨어지면 그 몫이 정답이다
    * 나누어 떨어지지 않으면 3킬로 봉지를 하나 추가하여 그 나머지가 5로 나누어 떨어지는지 확인
    * 나누어 떨어지면 봉지의 개수 출력, 아니면 3킬로 봉지를 추가하고 나누어 떨어지는지 확인하는 과정 반복
    * 나누어 떨어지는 경우 오지 않으면 -1 출력, 있으면 결과 값 출력
    * 코드
    ```
    #include<iostream>
    #include<algorithm>
    using namespace std;

    int main() {
	int result=-1;
	int n;
	int temp;
	cin >> n;
	temp = n;
	for (int i = 0; i <= (n / 3); i++) {
		temp = n-(3*i);
		if (temp % 5 == 0) {
			result = temp / 5 + i;
			break;
		}
	}
	cout << result << "\n";

	return 0;
    }
    ```
