# 03 배열, 구조체, 포인터
## 3.1 배열
### 배열의 개념
* **동일한 타입**의 데이터를 한 번에 여러 개 저장할 때 사용하는 자료구조
* 연속적인 메모리 공간에 저장됨
* 인덱스 번호를 이용하여 개별 변수보다 각 요소 쉽게 접근 가능하다
    * 반복 루프를 이용해 여러 가지 작업을 손쉽게 할 수 있음

### 배열의 ADT
* ADT of Array
    * 객체 : <index,value> 쌍의 집합
    * 연산 
        * create(size) ::= size개의 요소를 저장할 수 있는 배열생성
        * get(A,i) ::= 배열 A의 i번째 요소 반환
        * set(A,i) ::= 배열 A의 i번째 위치에 값 v 저장
    * 연산 ex)
        * int list[4];//create연산
        * list[0]=10;//set연산
        * value=list[3];//get연산
### 배열의 주소   
* 첫번째 배열의 요소의 주소가 배열의 기본주소가 된다. 
    *list=&list[0];
* list[i]의 주소= 기본주소+i*sizeof(데이터 타입) 번호에 있음 
* 배열 주소값을 이용한 연산 
    *ex) list+1 는 &list[1]과 같은 값 갖는다
## 3.2 구조체     
### 구조체의 개념
* 타입이 다른 데이터를 묶는 방법
* c에서는 struct 키워드 사용
* 구조체의 형식
    ```
    struct 구조체 이름{
        항목 1;
        항목 2;
        ...
    };
    ```
    *ex)
    ```
    struct studentTag{
    char name[10];
    int age;
    double gpa;
    };
    ```
* 구조체의 변수 생성 및 멤버 조작 법
    1. 생성 
        * struct 구조체이름 구조체변수; ->ex) struct studentTag s;
        * + struct stuendTag s={"Kim",20};-> 선언과 동시에 초기화도 가능
    2. 멤버 사용법 
        * .(멤버 연산자)를 이용해서 접근 
        * ex) s.age=20;,strcpy(s.name,"kim");
    3. typedef 사용법
        * 구조체를 새로운 타입으로 선언 가능하게 함
        * 정의 ex)  
        ```
        typedef struct studentTag{     //(or typedef struct {…})
        Char name[10];
        Int age;
        }student;
        ```
        * 생성 시 ex) student s;

## 3.3 배열의 응용 : 다항식 표현   
1. 모든 차수의 계수 값을 저장하는 방법
    * 계수 저장하는 배열, 차수 저장하는 변수 이용
    * 쉽게 이해가능하고, 덧셈, 뺄셈 등 연산 시 차수의 계수 쉽게 찾을 수 있어 알고리즘 쉬워짐
    * 대부분의 항의 계수가 0인 경우 저장공간 낭비 발생
2. 존재하는 항만 저장
//초기화 부분만 체크하여 다시 코딩

## 3.4 배열의 응용 : 희소 행렬

## 3.5 포인터 
### 포인터의 개념
    * 다른 변수의 주소를 가지고 있는 변수
    * 모든 변수는 메모리 공간에 저장되며 메모리의 각 바이트에는 주소가 매겨지는데 이 주소가 포인터 저장됨
        * ex) int a=100; int*p=p=&a;(p는 변수 a의 주소)
    * 컴퓨터 메모리는 바이트로 구성되어 각 바이트 마다 순차적으로 주소가 매겨짐
    * 포인터도 변수이므로 바이트 차지하며 주소 값 저장하는데 항상 4바이트 차지함

### 포인터 관련 연산자
* &연산자 : 주소연산자, 변수의 주소를 추출함
    * ex) &a -> 변수 a의 주소
* *연산자 : 간접 참조 연산자(역참조 연산자), 포인터가 가리키는 장소에 값을 저장하는 연산자
    * ex) *p=200; 포인터 p가 가리키는 값을 200으로 저장
* **주의**)int*p; p*200; -> 에러 : 초기화안된 포인터 변수는 역참조 불가능

### NULL pointer
* 어떤 객체도 가리키지 않는 포인터
* NULL키워드로 나타냄, 포인터 사용하기 전에 반드시 널 포인터인지 검사 해야 함
* null포인터와 초기화 안된 포인터는 다름 
    * 초기화 안된 포인터는 아무것도 가리키지 않는 걸 보장 못함

### 함수의 매개변수와 포인터 (Call by address방식) (C에서는 call by value와 call by address 만 존재)
* 포인터가 함수의 매개변수로 전달되면 그 포인터를 이용하여 함수 안에서 외부 변수 값을 변경 할 수 있다
* Call by value vs Call by address
    * ex) a=10,b=20
    1. Call by value
    ```
    void swap(int a,int b){
    int temp;
    temp=a;
    b=a;
    b=temp;  
    }
    swap(a,b); -> 결과 : a=10,b=20
    ```
    2. Call by address
    ```
    void swap(int *a,int *b){
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
    }
    swap(&a,&b); -> 결과 : a=20, b=10
    ```

### 배열과 포인터
* 배열의 이름은 배열의 시작위치 가리키는 주소 값 즉 포인터임 
    * 따라서, 함수의 인자로 배열이 전달되면 함수 안에서 배열의 내용 변경 가능하다!
* 실제로 컴파일러가 배열의 이름에 공간을 할당하지 않으며 배열의 첫 번째 요소의 주소로 대치한다
* 배열의 이름을 매개변수로 전달하면 함수 호출 시 배열 복사할 필요 없기 때문에 메모리 공간과 함수 호출 시간 절약 가능하다
* 예제)
    ```
    void get_integers(int list[]){
        printf("input 6 numbers : ");
        for(int i=0;i<6;i++)
        scanf("%d",&list[i]);
    }
    int cal_sum(int list[]){
        int sum=0;
        for(int i=0;i<6;i++)
        sum+=list[i];
        return sum;
    }
    int main() {
        int list[6];
        get_integers(list);
        printf("sum : %d\n",cal_sum(list));
        return 0;
    }
    ```

### 동적 메모리 할당(dynamic memory allocation)
* 얼마나 들어올지 모르는 입력에 메모리 낭비나 처리 오류(많은 입력 들어옴 등)을 방지하기 위한 메모리 할당 방법
* 필요한 만큼의 메모리를 OS한테 할당 받아 사용하고 끝나면 반납함
* 메모리를 효율적으로 사용가능하다
* heap(히프) : 동적 메모리가 할당되는 공간
* malloc.h 또는 stdlib.h 헤더 필요하다
* 예시 코드) int*p;
    1.P=(int*)malloc(sizeof(int));// 동적 메모리 할당
        * malloc(size) : size 바이트 만큼 메모리 블록 할당하고 동적 메모리 블록의 시작 주소 반환한다
        * void*형 반환하므로 적절한 type으로 형 변환 요구된다
        * 메모리 확보가 불가능하면 NULL을 함수의 반환 값으로 반환한다.

    2.*p=1000;// 동적 메모리 사용

    3. free(p);// 동적 메모리 반납
        * 할당된 메모리 블록을 OS에게 반환한다
        * malloc의 결과가 null인지 항상 검사하고 실행해야 함
    ```
    ```
### 구조체와 포인터
* '->'표기법 : 구조체 포인터를 통해 구조체의 멤버에 접근할 대 사용
    * ex) student *s; s->name;
* 구조체 자체를 함수로 전달하는 경우 구조체가 복사되어 함수로 전달되기 대문에 큰 구조체의 경우 구조체 포인터로 전달하는 것이 효율적이다
* ex)
    ```
    ```