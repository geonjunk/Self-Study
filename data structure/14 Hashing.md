# 14 해싱 
## 14.1 해싱이란?
### 해싱의 개요 
* 선형 탐색이나 이진 탐색은 모두 키를 저장된 키값과 반복적으로 비교함으로써 탐색하고자 하는 항목에 접근하며 이러한 방법들은 최대 가능 시간 복잡도가 O(logn)임
* 더 빠른 탐색 알고리즘이 요구될 때(O(1)시간 안에 탐색알 수 있는 알고리즘 요구될 때) 해싱 사용
	* Ex) 전화번호를 통해 주소 확인하는 긴급 출동 시스템
### 해싱의 개념
* 해싱 : 키(key)에 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근하는 방법, 어떤 항목의 키만을 가지고 바로 항목이 들어 있는 배열의 인덱스를 결정하는 기법
* 해시 함수 : 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
* 매핑 전 데이터를 키 / 매핑 후 데이터를 해시 값(hash value)이라 함
* 해시 테이블(hash table) : 키에 연산에 의해 직접 접근이 가능한 구조, 해시값을 색인(index) 혹은 주소 삼아 데이터 값을 키와 함께 저장하는 구조
* 해싱(hashing) : 해시 테이블을 이용한 탐색
	*Ex) 컴파일러가 사용하는 심볼 테이블, 철자 검사기, 데이터베이스 등에서 해싱 사용
* 일상생활에서 정리 정돈으로 비유 가능한데 정리정돈을 잘 못하는 사람은 물건들을 섞여있는 상태에서 필요할 때 하나씩 탐색, 정리 정돈 하면 항상 제자리에 둠(ex) 열쇠는 항상 책상위에)으로 물건이 필요할 때 그 위치 바로 찾아가면 됨
* 해싱은 정리정돈을 잘 해놓은 것
* 해싱은 사전(dictionary)이라는 자료구조 구현 시 최상의 선택임

## 14.2 추상 자료형 사전
### 사전의 개념
* (키,값) 쌍의 집합으로 키와 관련된 값을 동시에 저장하는 자료구조
(키(key) : 사전의 단어처럼 항목과 항목을 구별시켜주는 것 / 값(value) : 단어의 설명에 해당)
* (키,값) 쌍을 저장, 삭제할 수 있고 키를 가지고 값을 검색 가능
* 맵(map)이나 테이블(table)로 불리기도 한다
* 항목들을 키에 의하여 식별하고 관리하며, 항목들의 위치는 상관없음 -> 항목들을 접근하고 삭제하려면 키만 가지고 있으면 됨
* 사전은 오직 키에 의해서만 관리되므로 다른 자료구조(ex)리스트-위치에 의해 관리)와 비교됨
* 사전은 무조건 키를 통해 항목에 접근할 수 있으면 되므로 정렬여부는 구현할 때에 결정해야 할 문제임
* 사전의 ADT
	* 객체 : 일련의 (key,value)쌍의 집합
	* 연산
		* Add(key,value) ::=(key,value)를 사전에 추가
		* Delete(key)::=key에 해당하는 (key,value)를 찾아서 삭제하고 관련된 value반환,실패하면 NULL반환
		* Search(key)::=key에 해당되는 value를 찾아서 반환, 실패하면 NULL반환
* 사전을 효율적으로 구현하기 위해서는 연산 3가지 (Add, delete,search)를 효율적으로 구현해야 함
* 이진탐색트리로도 사전을 구현할 수 있으나 최악의 경우 O(n)의 시간복잡도 가진다. 따라서 가장 효율적으로 구현하는 방법은 해싱(키의 비교가 아닌 키에 수식을 적용시켜서 바로 키가 저장된 위치를 얻는 방법) 

## 14.3 해싱의 구조
### 해싱의 기본적인 아이디어
* ex) 회사 직원들에 대한 정보를 빠르게 저장하고 탐색하려면 직원의 아이디를 키(배열의 인덱스)라 생각하고 배열의 특정 요소를 읽거나 쓰면됨 -> 시간 복잡도 O(1)
* 해싱은 자료를 저장하는데 배열 사용 -> 원하는 항목 들어있는 위치를 알고 있다면 매우 빠르게 자료를 삽입하거나 꺼낼 수 있다는 장점 이용
* 현실적으로는 탐색 키들이 문자열이거나 매우 큰 수이므로 탐색 키를 작은 정수로 사상(mapping)시키는 함수 요구됨
* 해시함수(hash function)는 키를 입력 받아 해시 주소(hash address)를 생성하고 이 해시주소를 해시테이블(hash table)의 인덱스로 사용한다.
	* Ex) k(key) -> 해시함수에 입력 ->h(k)를 인덱스로 사용해 해시 테이블 접근
* 해시 테이블(ht)은 버킷(bucket)으로 이루어지는 테이블로 M개의 버킷으로 이루어져 있다 하면ht[0]..ht[M-1]의 원소를 가짐
* 하나의 버킷은 여러 개의 슬롯(slot)가질 수 있음  
```
사진 
```
* 하나의 버킷에 여러 개의 슬롯을 두는 이유 : 서로 다른 두 개의 키가, 해시함수에 의해 동일한 해시 주소로 변환될 수 있으므로 여러 개의 항목을 동일한 버킷에 저장하기 위함 
* 대부분 하나의 버킷은 하나의 슬롯 가짐
* 해시 테이블에 존재하는 버킷의 수가 M이므로 해시함수 h는 모든 키에 대하여 0≤h(x)≤M-1의 범위의 값 제공해야 하는데 대부분의 경우 버킷 수는 모든 키의 경우의 수보다 매우 작으므로 여러 개의 서로 다른 키가 같은 해시 주소로 사상되는 경우 자주 발생
* 서로 다른 두개의 키 k1과 k2에 대해 h(k1)=h(k2)인 경우 충돌(collision)이라고 하며, k1과 k2를 동의어(synonym)라 함
* 충돌 시 같은 버킷에 있는 다른 슬롯에 항목을 저장 함
* 충돌이 자주 발생하면 버킷 내부에서의 순차 탐색 시간이 길어져 탐색 성능이 저하될 수 있으므로 해시함수 수정하거나 해시테이블의 크기를 적절히 조절해 주어야 함
* 이러한 충돌이 버킷에 할당된 슬롯 수보다 많이 발생하면 버킷에 더 이상 항목을 저장할 수 없게 되는 오버플로우(overflow)발생
* 슬롯 수 1개이면 충돌이 곧 오버플로우
* 오버플로우 발생하면 더 이상 항목을 저장할 수 없게 되므로 오버플로우 해결하기 위한 방법 요구됨

### 이상적인 해싱 
* 예제) 학번을 키라고 할 때 뒤에 3개의 숫자순서로 학생 저장한다고 하면 h(abcde)=cde이므로 ht[cde]에 학생의 인적 사항 저장한다.
* 이상적인 해싱은 해시 테이블이 충분한 공간 가지고 있으면 잘 동작함 
	*(해시함수가 0~999까지 생성하면 해시 테이블 1000개의 공간 가지면 충분한 공간임)
* 이상적인 해싱 알고리즘
	* add(key,value):
		Index<- hash_function(key)
		ht[index]=value
	* search(key):
		Index<-hash_function(key)
		return ht[index]

### 실제의 해싱 
* 보통의 경우 키는 매우 많고, 해시 테이블의 크기는 제한적이다 -> 하나의 키당 하나의 공간을 할당할 수 없다
	* Ex) 주민등록번호 13자리 십진수 이므로 ?10?^13개 정도의 공간 필요-> 굉장히 큼
* 따라서, 일반적인 경우 키에 비하여 해시 테이블의 크기가 작고 또 일반적으로 키 중에 일부만 사용되기 때문에 전체를 위한 공간을 항상 준비할 필요는 없다.
* 해시함수와 슬롯을 이용하는 방법이 있지만 두 개 이상의 키가 동일한 해시 테이블 주소공간으로 매핑되는 충돌 문제와 오버플로우가 빈번하게 발생함
* 실제의 해싱은 충돌과 오버플로우의 빈번한 발생으로 시간 복잡도는 이상적인 경우 O(1)보다 떨어지게 됨 ->충돌과 오버플로우 해결책 필요

## 14.4 해시함수
### 해시 함수의 개요
* 해싱에서 키 값을 해시테이블의 주소로 변환하는 해시 함수가 잘 설계되어야 탐색의 효율 증대
* 좋은 해싱 함수의 조건
	1. 충돌이 적어야함
	2. 해시함수 값이 해시테이블의 주소 영역 내에서 고르게 분포되어야 함
	3. 계산이 빨라야 함
* 해시 테이블의 크기 M이면 해시 함수가 키를 [0,M-1]의 범위의 정수로 변환시켜야 함

### 제산 함수
* 나머지 연산(mod)를 사용해 키를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법 
* 가장 일반적인 방법의 해시 함수로 해시 주소를 상당히 고르게 분포시키는 좋은 방법
* h(k)=k mod M (k는 키, M은 해시테이블의 크기) 
* 해시 함수 값의 범위가 0~M-1이므로 인덱스로 사용하기 적합함
* 해시 테이블의 크기 M은 주로 소수(prime number)로 선택 -> 해시테이블에서 한쪽으로 편향되는 현상 막기 위해
	* M이 짝수면 k mod M이 k가 짝수일때는 짝수, k가 홀수면 홀수가 됨 (메모리 대상 해싱인 경우 주로 k가 짝수(메모리는 2의배수)), 따라서 M은 항상 홀수여야 하며 또한, 소수면 자기 자신과 1만을 약수로 갖기 때문에 골고루 사용하는 결과 값 만들어 낼 수 있기 때문에 소수로 선택한다.
* 나머지 연산의 경우가 음수일 가능성에 대비해 k mod M이 음수면 +M을 하여 결과 값 0~(M-1)이 되도록 함
* 최종함수 
```
int hash_fun(int key){

int hash_index=key%M;
if(hash_index<0) hash_index+=M;
return hash_index;

}
```
### 폴딩 함수	
* 키의 일부만 사용하는 것이 아닌 키를 몇 개의 부분으로 나누어 이를 더하거나 비트별로 XOR같은 부울 연산하는 방법
* 키를 마지막 부분을 제외한 모든 부분의 길이가 동일하게 여러 부분으로 나누고, 이들 부분을 모두 더하거나 XOR연산하여 인덱스로 이용하는 방법 -> 폴딩(folding)이라 함
* 주로 키가 해시 테이블의 크기보다 더 큰 정수일 경우 사용
	* Ex) 해시 테이블의 인덱스 16비트 정수지만 키는 32비트 정수인 경우
		* Hash_index =(short)(key^ (key>>16))
		* (^: 비트 XOR연산, 대응되는 비트가 다르면 1반환, >> x: x만큼 오른쪽으로 비트이동)
* 키를 나누고 더하는 방법 2가지
	1. 이동 폴딩(shift folding) : 각 부분의 값을 계산하기 위해 마지막을 제외한 모든 부분을 길이가 동일하게 여러 부분으로 나누고 이 부분을 모두 더하여 해시 주소로 사용하는 방법
		* (최하위 비트 (LSB)가 마지막 부분의 자리와 일치하도록 우측 끝을 맞추어 더함)
	2. 경계 폴딩(boundary folding) : 원래의 키(key)값을 여러 부분으로 나눈 후, 나누어진 각 부분의 경계선을 종이 접어 역으로 정렬한 다음 같은 자리에 위치한 수를 더한 값을 버킷 주소(인덱스)로 사용하는 방법
	* ex) 탐색키 123 | 203 | 241 |112| 20
		* 이동폴딩 : 123+203+241+112+20=699
		* 경계폴딩 : 123+302+241+211+20=897

### 중간 제곱 함수
* 키를 제곱한 다음, 중간에 있는 적당한 비트를 취하여 해시 주소를 생성하는 방법	
* 제곱한 값의 중간 비트들은 대개 키의 모든 값과 관련이 있어 서로 다른 키는 몇 개의 문자가 같을 지라도 서로 다른 해싱 주소를 갖게 된다.

### 비트 추출 방법 
* 해시 테이블의 크기 M=2^k일 때 키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시 주소로 사용
* 간단하지만 키의 일부 정보만 사용하기 때문에 해시 주소의 집중 현상이 일어날 가능성 높다

### 숫자 분석 방법
* 숫자로 구성된 키에서 각각의 위치에 있는 수의 특징을 미리 알고 있을 때 유용한 방법으로, 키의 각각의 위치에 있는 숫자 중에서 편중되지 않는 수들을 해시 테이블의 크기에 적합한 만큼 조합하여 해시 주소로 사용하는 방법
* ex) 201711287 (학번) 에서 2017 편중되어 있으므로 나머지 수를 조합하여 해시 주소로 사용

### 탐색 키가 문자열일 경우 주의할 점 
* 키들이 정수면 비교적 쉽게 해시 주소로 변환 가능하지만 키들이 문자열인 경우도 존재
* 대개 문자열 안의 문자에 정수를 할당하여 바꾸는 방법도 있긴 함
ex) a~z ->1~26
* 가장 보편적인 방법은 문자의 아스키 코드 값이나 유니 코드 값을 사용하는 것
	1. 첫번째 문자의 코드 값을 해시 주소로 이용 : 가장 간단한 방법, 첫번째 문자 같으면 구별 불가능
		* ex) book<->cup 은 구별(O) , cup <->car 구별 불가능
	2. 각 문자의 코드 값을 모두 더하는 방법 : 서로 다른 키들이 같은 문자로 이루어져 있지 않는 한, 비교적 잘 작동, 키들이 동일한 문자로 이루어져 있지만 위치가 다른 겨우 구분 불가능, 3자리로 이루어진 키의 경우 해시 코드 집중 현상 발생
	3. 글자들의 코드 값에 위치에 기초한 값을 곱하는 방법 : 문자열 s가 n개의 문자를 가지고 있다고 가정하고 s안의 i번째 문자가 u_i라고 하면 
		* =u_0 g^(n-1) +u_1 g^(n-2)+… +u_(n-2) g+u_(n-1) (g는 양의정수 보통 31을 사용)
		* 계산량을 줄이기 위하여 호너의 방법(Horner's method)사용 가능 ->(..((u_0 g^ +u_1)g+u_2)g+…+u_(n-2))g+u_(n-1)
		*  코드)
			```
			int hash_fun(char*key){
				int hash_index=0;
				while(*key)
					hash_index=g*hash_index+*key++;
			return hash_index;
			}
			```

* 키가 긴 문자열로 되어 있을 경우, 프로그램상 오버플로우 발생 가능, 오버플로우 발생하면 해시코드의 값 음수가 될 수 있으므로 이런 경우 검사해야 함
## 14.5 개방 주소법
### 충돌과 오버플로우
* 충돌(collision) : 서로 다른 키를 갖는 항목들이 같은 해시주소를 갖는 현상
* 충돌이 발생하고 해시 주소에 더 이상 빈 버킷이 남아 있지 않으면 오버플로우가 발생하고 해시 테이블에 항목을 더 이상 저장하는 것이 불가능
* 오버플로우를 효과적으로 해결하는 방법 2가지
	1. 개방 주소법(opening addressing) : 충돌이 일어난 항목을 해시 테이블의 다른 위치에 저장하는 방법으로 특정 버킷에서 충돌이 발생하면, 비어있는 버킷을 찾는 방법이다.
		* 종류 : 선형 조사법(linear prob-ing), 이차 조사법(quadratic probing), 이중 해싱법(double hashing), 임의 조사법(random probing) 등
		* 조사(probing) : 해시 테이블에서 비어있는 공간을 찾는 것
	2. 체이닝(chaining) : 해시테이블의 하나의 위치가 여러 개의 항목을 저장할 수 있도록 해시테이블의 구조를 변경
 
### 선형 조사법
* 선형 조사법 : 선형으로 비어있는 공간이 나올 때까지 조사하는 방법 
* ht[k]에서 충돌이 발생했다면 ht[k+1]이 비어있는지 확인하고 비어있지 않다면 ht[k+2].. 이런 식으로 비어있는 공간이 나올 때까지 계속하여 조사한다 (h(k),h(k)+1,h(k)+2…)
* 테이블의 끝에 도달하게 되면 다시 테이블의 처음으로 가고, 조사를 시작했던 곳으로 되돌아오면 테이블이 가득 찬 것으로 판단한다.
* 구현
	* 해시 테이블은 1차원 배열로 구현하며 각 요소들은 초기화 과정 즉, 각 버킷들을 공백상태로 만드는 과정 필요
	* 문자열에서 첫문자가 NULL이면 공백상태임 
```
 #include<stdio.h>
#include<stdlib.h>
#include<string.h>


#define KEY_SIZE 10
#define TABLE_SIZE 13
#define empty(item)(strlen(item.key)==0)
#define equal(item1,item2)(!strcmp(item1.key,item2.key))


typedef struct element{
	char key[KEY_SIZE];
}element;


element hash_table[TABLE_SIZE];
void init_table(element ht[]){
	int i;
	for(i=0;i<TABLE_SIZE;i++){
		ht[i].key[0]=NULL;//첫 문자가 NULL이면 비어있는것임 (문자열은 맨끝이 NULL로 채워짐)
	}
}
int transform(char*key){
	int hash_num=0;
	while(*key){
		hash_num=hash_num+*key++;// -> 실제로는 이 방법 더 많이 사용함
	}
	return hash_num;
}
int hash_fun(char*key){
	return transform(key)%TABLE_SIZE;
}
void hash_lp_add(element e,element ht[]) {//해시테이블에 키 추가하는 함수
	int i=hash_fun(e.key);
	int num=i;
	while(!empty(ht[i])){
		if (equal(e, ht[i])) {
			fprintf(stderr,"탐색 키가 중복되었습니다\n");
			exit(1);
		}
		i=(i+1)%TABLE_SIZE;
		if (i == num) {
			fprintf(stderr, "테이블이 가득찼습니다\n");
			exit(1);
		}

	}
	ht[i]=e;

}

void hash_lp_search(element e, element ht[]) {//탐색하는 함수	
	int i=hash_fun(e.key);
	int num=i;
	while(!empty(ht[i])){
		if (equal(e, ht[i])) {
			fprintf(stderr, "탐색 %s: 위치 =%d\n",e.key,i);
			return ;

		}
		i=(i+1)%TABLE_SIZE;
		if (i == num) {
			fprintf(stderr, "찾는값이 존재하지 않음\n");
			exit(1);
		}

	}
	fprintf(stderr, "찾는값이 존재하지 않음\n");//다음 칸 비어있으면 찾는 값 존재 안하는 것 

}
void hash_lp_print(element ht[]) {
	int i;
	printf("\n===================================\n");
	for (i = 0; i < TABLE_SIZE; i++) {
		printf("[%d] %s\n", i, ht[i].key);
	}
	printf("\n===================================\n");
}
int main() {
	char *s[7] = { "do","for","if","case","else","return","function" };
	element e;
	int i;
	init_table(hash_table);
	for (i = 0; i < 7; i++) {
		strcpy(e.key, s[i]);
		hash_lp_add(e, hash_table);
		
	}
	hash_lp_print(hash_table);
	for (i = 0; i < 7; i++) {
		strcpy(e.key, s[i]);
		hash_lp_search(e,hash_table);
		
	}

	return 0;
}

``` 
* 참고) 실제 응용에서는 탐색 키와 관련된 자료를 찾을 것이므로 사전을 구현하는 경우 단어의 설명이 테이블에 키와 함께 저장될 것
* 참고) fprintf 와 printf의 차이 -> fprintf는 버퍼없이 바로 출력
* 군집화(clustering) : 한번 충돌이 시작되면 그 위치에 항목들이 집중되는 현상, 선형조사법 이용시 발견될 수 있음
* 간단하지만 키들이 집중되어 저장되는 현상 발생하게 되고, 최악의 경우에는 집중된 항목들이 결합 하는 현상까지 발생 가능하므로 탐색 시간이 길어지는 단점 가짐
	* 간단하다는 장점, 오버플로우가 자주 발생하면 집중과 결합에 의해 탐색의 효율 떨어지는 단점
* 선형 조사법에서 삭제 구현시 항목이 삭제되면 탐색이 불가능해질 경우가 발생할 수 있기 때문에 한번도 사용 안 한 버킷과 사용했지만 삭제된 버킷 구분해야한다.
	* ex) 5,15,25 가 주소 5에서 충돌이 발생해서 선형조사법으로 저장했을 때 15 삭제시 25까지 탐색 못하는 경우 생길 수 있음

### 이차 조사법
* 선형 조사법과 유사하지만 다음 조사할 위치를 다음 식에 의해 결정
	* (h(k)+inc*inc) mod M for inc=0,1,..M-1
		* ->h(k)+1,h(k)+4,h(k)+9..
* 모든 위치 조사하게 하려면 테이블의 크기 소수여야 함
* 선형조사법의 문제인 집중과 결합 완화 가능
* 2차 집중 문제를 일으킬 수 있으나 1차 집중처럼 심각한 것은 아님
* 2차집중은 동일한 위치로 사상되는 여러 키들이 같은 순서에 의해 빈 버킷을 조사하기 때문에 발생 -> 이중 해싱법으로 해결 가능
* 구현
```
void hash_qp_add(element e, element ht[]) {
	int i=hash_fun(e.key); 
	int num=i;
	int inc=1;
	while(!empty(ht[i])){
		if (equal(e, ht[i])) {
			fprintf(stderr,"탐색 키가 중복되었습니다\n");
			exit(1);
		}
		i=(i+inc*inc)%TABLE_SIZE;
		inc++;
		if (i == num) {
			fprintf(stderr, "찾는값이 존재하지 않음\n");
			exit(1);
		}	
		
	}	
	
	ht[i]=e;
	
}
``` 
### 이중 해싱법 (또는 재해싱)
* 오버플로우가 발생함에 따라 항목을 저장할 다음 위치를 결정할 때, 원래 해시 함수와 다른 별개의 해시 함수를 이용하는 방법->항목들을 해시 테이블에 보다 균일하게 분포시킬 수 있음
* 선형, 이차 조사법은 충돌 발생 시 어떤 값을 더해서 다음 조사하는 위치를 얻는데 해시 함수 값이 같으면 차후에 조사되는 위치도 같게 되지만 이중 해싱법에서는 키를 참조하여 더해지는 값이 결정되므로 해시 함수 값이 같더라도 키가 다르면 서로 다른 조사 순서를 갖기 때문에 이차 집중 피할 수 있다 
* 두 번째 해시함수는 일반적으로 조사 간격을 정함
	* 조사간격(step)=C-(k mod C)  (C는 M보다 약간 작은 소수)
* (충돌 시) 조사되는 위치 : h(k),h(k)+step,h(k)+step*2…
	* ex) h(13)=13 mod 7=6 , h^'(13)=5-(13mod 5)=2 이면 6 ,(6+2)mod 7=1 순서로 탐색 (테이블 크기 넘어 가는 경우 있기 때문에)
* 구현
```

void hash_dh_add(element e, element ht[]) {
	int i=hash_fun(e.key); 
	int num=i;
	int inc=hash_fun2(e.key);//두번째 해시 함수 
	while(!empty(ht[i])){
		if (equal(e, ht[i])) {
			fprintf(stderr,"탐색 키가 중복되었습니다\n");
			exit(1);
		}
		i=(i+inc)%TABLE_SIZE;
		inc++;
		if (i == num) {
			fprintf(stderr, "찾는값이 존재하지 않음\n");
			exit(1);
		}	
		
	}	
	
	ht[i]=e;
	

}
``` 
* 같은 버킷과 같은 탐색 순서를 가지는 요소들이 거의 없기 때문에 집중 현상이 매우 드물다
* 테이블의 크기가 소수인 경우에는 모든 인덱스 탐색하지만 소수아니면 같은 위치 되풀이 하므로 테이블의 크기는 꼭 소수!
* 선형 조사법은 한번도 사용되지 않은 위치가 있어야 만 탐색이 빨리 끝남 -> 모든 위치가 사용되고 있거나 사용된 적이 있는 위치면 실패하는 탐색인 경우 테이블의 모든 위치를 조사하게 됨
* 체이닝 방법은 이러한 문제점 없음!

## 14.6 체이닝 
### 체인법
* 선형 조사법은 충돌 때문에 해시 주소가 다른 키하고도 비교를 해야하기 때문에 탐색 시간이 많이 걸림 -> 해시 주소가 같은 키만을 하나의 리스트로 묶은다면 불필요한 비교 하지 않아도 됨
* 체이닝 : 해시 테이블의 구조를 변경하여 각 버킷이 하나 이상의 값을 저장할 수 있도록 하는 것으로, 각 버킷에 고정된 슬롯이 아닌 삽입과 삭제가 용이한 연결리스트를 할당한다.
* 연결리스트에 어디에다 새로운 항목을 삽입하는지도 결정해야 하는데 키의 중복을 허용하면 처음에 삽입하는 것이 가장 좋고 허용이 되지않는다면 연결리스트 처음부터 탐색하여야 하므로 어차피 맨 뒤를 가야하기 때문에 뒤에다 삽입하는 것이 자연스럽다.
* 해시 테이블을 연결리스트로 구성하므로 필요한 만큼의 메모리만 사용하게 되어 공간적 사용 효율 매우 우수
* 오버플로우 발생 시에도 해당 버킷에 할당된 연결 리스트만 처리하게 되므로 수행 시간 면에서도 매우 효율적

### 구현
```
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define KEY_SIZE 10
#define TABLE_SIZE 7
#define SIZE 5

typedef struct element{
	int key;
}element;
typedef struct list {
	element item;
	struct list*link;
}list;

struct list*hash_table[TABLE_SIZE];
int hash_fun(int key) {// key값 int이므로 바로 해시함수  
	return key % TABLE_SIZE;
}
void hash_chain_add(element e,list*ht[]) {
	int i=hash_fun(e.key);
	list*node=ht[i];
	list*before=NULL;
	while(node!=NULL){//중복허용 x ->마지막에 삽입 
		if(node->item.key==e.key){
			fprintf(stderr,"이미 있는 탐색키입니다\n");
			return;
		}
		before=node;
		node=node->link; 
	}
	list*ptr=(list*)malloc(sizeof(list));
	ptr->item=e;
	ptr->link=NULL;
	if(before==NULL){
		ht[i]=ptr;
	}else{	
		before->link=ptr;
	}
	
}
void hash_chain_search(element e,list*ht[]){
		int i=hash_fun(e.key);
	list*node=ht[i];
	while(node!=NULL){
		if(node->item.key==e.key){
			fprintf(stderr,"탐색 %d 성공\n",e.key);
			return;

		}
		node=node->link; 
	}
	printf("키를 찾지못했음\n");	
}
void hash_chain_print(list*ht[]){
	list*node;
	int i;
	printf("\n==================================\n");
	for(i=0;i<TABLE_SIZE;i++){
		printf("[%d]->",i);
		for(node=ht[i];node!=NULL;node=node->link){
			printf("%d->",node->item.key);
		}
		printf("\n");
	}
} 

int main() {
	int data[SIZE]={8,1,9,6,13};
	element e;
	int i;
	
	for(i=0;i<SIZE;i++){
		e.key=data[i];
		hash_chain_add(e,hash_table);
		hash_chain_print(hash_table);
	}
	
	for(i=0;i<SIZE;i++){
		e.key=data[i];
		hash_chain_search(e,hash_table);
	}
	return 0;
}

``` 
## 14.7 해싱의 성능 분석
* 해시 테이블에 자료를 추가하거나 자료를 꺼내거나 자료를 삭제하는 연산들은 모두 탐색연산을 사용하기 때문에 해싱에서의 가장 중요한 연산은 탐색 연산 
* 충돌이 없는 이상적인 해싱의 시간 복잡도는 O(1) 
* 적재 밀도(loading density) 또는 적재 비율(loading factor) :  해시 테이블이 얼만 채워져 있는지를 나타내는 하나의 척도, 저장되는 항목의 개수n 과 해시테이블의 크기 M 의 비율
	* a=n/M
	* a가 0이면 비어있는 해시테이블
	* 선형조사법에서 a의 최대값 : 1(꽉 차있을때) / 체인법에서는 최대값 존재 x
	* 선형 조사법에서는 해시테이블이 채워지면 충돌이 더 자주 일어남
	* a 가 0.5가 넘어가면 급격하게 탐색시간 늘어나므로 0.5넘지 않게 하기
	* 체이닝 방법에서는 a= 항목의개수/연결리스트의 개수 
* 해싱은 이진 탐색과 비교했을 때 삽입이 쉽지만 크기순으로 순회하기 어렵고 최악의 경우 O(n)이다 