# 8. mongoDB
## NoSQL(Not only SQL) vs SQL
* SQL(MySQL)
    * 규칙에 맞는 데이터 입력
    * 테이블 간의 JOIN 지원
    * 안정성, 일관성
    * 용어(테이블, 로우, 컬럼)

* NoSQL(몽고디비)
    * 자유로운 데이터 입력
    * 고정된 테이블이라는 개념이 없으며 이에 상응하는 컬렉션 개념이 있지만 컬럼을 따로 정의하지 않음
    * 로우대신 다큐먼트라는 용어 사용
    * 컬렉션 간 JOIN 미지원
    * 확장성, 가용성 -> 데이터의 일관성을 보장해주지 못하지만, 데이터를 빠르게 넣고 여러 서버에 쉽게 데이터를 분산할 수 있음
    * 용어(컬렉션, 다큐먼트, 필드)

* 2개를 동시에 사용하는 경우도 있음
    * 세션, 데이터, 메시징 관리 -> nosql
    * 비행기표에 관한 정보 -> sql(일관성 있게 정보를 전달해야하므로)


## 데이터베이스 및 컬렉션 생성
* 데이터베이스 생성
    * use [데이터베이스명]
* 데이터베이스 목록 조회
    * show dbs
* 현재 사용중인 DB 확인
    * db 
* 컬렉션 생성
    * db.createCollection('컬렉션명')
    * 참고) 컬렉션은 따로 생성하지 않아도 다큐먼트를 넣은 순간 자동으로 생성됨
* 생성한 컬렉션 목록 확인
    * show collections
* 다큐먼트 추가

* compass로 생성 가능

## CRUD 작업
* 몽고디비 자료형
    * 몽고디비는 자바스크립트 문법을 따르므로 기본적으로 자바스크립트 자료형을 따른다
    * Date, 자바스크립트 객체, 추가적으로 Binary Data, ObjectId, Int, Long, Decimal, Timestamp, Javascript등의 자료형 존재
        * ObjecetId : MySQL의 기본키로 쓰이는 값과 비슷한 역할, 고유값 가짐
    * Undefined와 Symbol은 자료형으로 사용하지 않음
* Create(생성)
    * db.컬렉션명.save(다큐먼트);
    * ex) db.users.save({name:'zero',age:24, married: false, comment:'안녕하세요',createdAt: new Date()});
* Read(조회)
    * db.컬렉션명.find({});
    * ex1) db.users.find({});
    * ex2) db.users.find({},{_id:0,name :1, married : 1}); -> 특정 필드 조회 (0은 가져오지 않고 1만 가져옴)
    * ex3) db.users.find({age : {$gt : 30 }, married : true},{_id:0, name:1,age:1}); -> 특정 조건으로 가져옴 30초과, married가 true인 것만 가지고옴
    * 연산자 
        * $gt(초과), $gte(이상), $lt(미만), $lte(이하), $ne(같지않음), $or(또는), $in(배열 요소 중 하나)등
    * sort() 매서드를 사용한 정렬가능 (-1 : 내림차순, 1 : 오름차순)
        * ex4) db.users.find({}).sort({age : -1})   
    * limit(조회할 다큐먼트 개수)
    * skip 메서드 : 몇개를 건너 뛸지
        * ex5) db.users.find({},{_id:0,name : 1, age:1}).sort({age:-1}).limit(1).skip(1)
* Update(수정)
    * db.컬렉션명.update(수정할 다큐먼트에 대한 정보가 담긴 객체, {$set : 수정할내용})
    * $set 연산자 사용
    * ex) db.users.update ({name:'nero'},{$set:{comment : '안녕하세요. 이필드를 바꿔보겠습니다!'}})
* Delete(삭제)
    * db.컬렉션명.remove(삭제할 다큐먼트에 대한 정보가 담긴 객체)
    * ex) db.users.remove({name : 'nero'});

## Mongoose 사용하기
* Mongoose -> ODM(Object Document Mapping) 
    * 릴레이션이 아니라 다큐먼트를 사용하므로
    * 몽고디비와 노드를 연동하고 서버에서 쿼리를 통해 데이터베으스 조작할 수 있게해줌
    * 몽고디비 자체가 자바스크립트인데도 굳이 JS와 매핑하는 이유 -> 몽고디비에 없어 불편한 기능 몽구스가 보완해줌
        * 스키마 생성
            * 잘못된 데이터 넣는 경우 방지하기 위해 몽구스는 데이터 넣기 전에 노드 서버단에서 데이터를 한 번 필터링하는 역할을 한다.
        * MySQL의 JOIN을 populate라는 메서드로 보완

* 몽고디비 연결하기 
    * 연결 파일 생성(schemas/index.js)
    ```javascript
    const mongoose = require('mongoose');

    const connect = () =>{
        if(process.env.NODE_ENV!=='production'){
            mongoose.set('debug',true);
        }
        mongoose.connect('mongodb://이름:비밀번호@localhost:27017/admin',{
            dbName:'nodejs',
            useNewUrlParser:true,
            useCreateIndex: true,
        },(error)=>{
            if(error){
                console.log('몽고디비 연결 에러',error);
            }else{
                console.log('몽고디비 연결 성공');
            }
        })

    };
    mongoose.connection.on('error',(error)=>{
        console.log('몽고디비 연결 에러',error);
    });
    mongoose.connection.on('disconnected',()=>{
        console.error('몽고디비 연결이 끊겼습니다. 연결을 재시도합니다.');
        connect();
    });

    module.exports=connect;
    ```
    * app.js에서 연결(app.js)
    ```javascript
    const express = require('express');
    const path=require('path');
    const morgan = require('morgan');
    const nunjucks = require('nunjucks');

    const connect = require('./schemas');

    const app = express();

    app.set('port',process.env.PORT||3002);
    app.set('view engine','html');
    nunjucks.configure('views',{
        express:app,
        watch:true,
    });
    connect();//연결하기

    app.use(morgan('dev'));//기존 로그대신 추가로그 볼 수 있음
    app.use(express.static(path.join(__dirname,'public')));//경로설정
    app.use(express.json());//json 형식으로보내면 req.body.객체명 : 이런식으로 접근 가능하게 함
    app.use(express.urlencoded({extended:false}));//nodejs에 기본으로 내장된 querystring 이용

    app.use((req,res,next)=>{
        const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`)
        error.status=404;
        next(error);
    });

    app.use((err,req,res,next)=>{
        res.locals.message=err.message;//전역에서 사용가능한 지역변수 생성
        res.locals.error=process.env.NODE_ENV!='production' ? err:{};
        res.status(err.status||500);
        res.render('error');
    });

    app.listen(app.get('port'),()=>{
        console.log(app.get('port'),'번 포트에서 대기 중');
    });
    ```

* 몽구스 스키마 정의하기
    * Schema 생성자를 이용해 생성, 몽구스는 알아서 _id를 기본키로 생성하므로 _id필드는 적어줄 필요없음
    ```javascript
    const mongoose = require('mongoose');

    const {Schema} =mongoose;
    const userSchema = new Schema({
        name:{
            type: String,
            required:true,
            unique:true,
        },
        age:{
            type : Number,
            required:true,
        },
        married:{
            type:Boolean,
            required: true,
        },
        comment: String,
        createdAt:{
            type : Date,
            default:Date.now,
        },
    });

    module.exports=mongoose.model('User',userSchema);
    ```
    * ref 속성 이용
    ```javascript
    const mongoose = require('mongoose');

    const {Schema}=mongoose;
    const {Types:{ObjectId}}=Schema;
    const commentSchema=new Schema({
        commenter:{
            type:ObjectId,
            require:true,
            ref:'User',//commenter 필드에 User 스키마의 사용자 ObjectId가 들어감 
        },
        comment : {
            type:String,
            required:true,
        },
        createdAt:{
            type:Date,
            default:Date.now,
        }
    })

    module.exports=mongoose.model('Comment',commentSchema);
    ```

### 쿼리 사용하기
* 생성 : 모델.create 메서드 활용
* 조회 : 모델.find({}) or 모델.findOne({}) 메서드 이용
* 수정 : 모델.update({업데이트할 값 조건},{업데이트 내용}) 메서드 이용
* 삭제 : 모델.remove({삭제할 값 조건})
* 참고) 모델 -> 스키마를 이용해 만든 인스턴스
* populate 메서드
    * 해당 ref의 다큐먼트 값을 가져옴
        * ex) populate('commenter') -> commenter 필드로 ObjectId가 아닌 해당 ObjectId를 가진 User 다큐먼트 가져옴
        * ex2) comment.populate(comment,{path : 'commenter'}) : comment 객체의 다른 컬렉션 다큐먼트를 가져옴, path 옵션으로 어떤 필드를 합칠지 설정함
* 코드
    * user.js
    ```javascript
    const express = require('express');
    const User = require('../schemas/user');
    const Comment = require('../schemas/comment');

    const router = express.Router();

    router.route('/')
    .get(async (req, res, next) => {
        try {
        const users = await User.find({});
        res.json(users);
        } catch (err) {
        console.error(err);
        next(err);
        }
    })
    .post(async (req, res, next) => {
        try {
        const user = await User.create({
            name: req.body.name,
            age: req.body.age,
            married: req.body.married,
        });
        console.log(user);
        res.status(201).json(user);
        } catch (err) {
        console.error(err);
        next(err);
        }
    });

    router.get('/:id/comments', async (req, res, next) => {
    try {
        const comments = await Comment.find({ commenter: req.params.id })
        .populate('commenter');//
        console.log(comments);
        res.json(comments);
    } catch (err) {
        console.error(err);
        next(err);
    }
    });

    module.exports = router;
    ```

    * comments.js
    ```javascript
    const express = require('express');
    const Comment = require('../schemas/comment');

    const router = express.Router();

    router.post('/', async (req, res, next) => {
    try {
        const comment = await Comment.create({
        commenter: req.body.id,
        comment: req.body.comment,
        });
        console.log(comment);
        const result = await Comment.populate(comment, { path: 'commenter' });
        res.status(201).json(result);
    } catch (err) {
        console.error(err);
        next(err);
    }
    });

    router.route('/:id')
    .patch(async (req, res, next) => {
        try {
        const result = await Comment.update({
            _id: req.params.id,
        }, {
            comment: req.body.comment,
        });
        res.json(result);
        } catch (err) {
        console.error(err);
        next(err);
        }
    })
    .delete(async (req, res, next) => {
        try {
        const result = await Comment.remove({ _id: req.params.id });
        res.json(result);
        } catch (err) {
        console.error(err);
        next(err);
        }
    });

    module.exports = router;
    
    ```