# 7 MySql
## 7.1 데이터베이스란?
* 보안의 위협이 되지않는 데이터는 클라이언트에 두고, 보안에 위협이 되는 데이터는 서버에 저장함 (-> 서버에 다 저장되면 비용상 비효율적이므로 다 서버에 저장하지 않고 서버를 최대한 가볍게 하는게 좋음)
* 지금까지는 데이터를 서버 메모리에 저장함 -> 서버를 재시작하면 데이터도 사라짐 -> 영구적으로 저장할 공간 필요 -> 데이터베이스 사용
* 데이터베이스 : 관련성을 가지며 중복이 없는 데이터들의 집합
* 이러한 DB를 관리하는 시스템을 DBMS라고 함
* 보통 서버의 HDD, SSD등의 저장매체에 데이터를 저장함 -> 서버 종료와 상관없이 데이터를 지속적으로 사용가능
* RDBMS : 관계형 DBMS, SQL이라는 언어를 사용해 데이터를 관리 ex) MySql, OracleSql 등
    * 관계형 데이터베이스 : 데이터끼리 서로 관계를 맺고있음
* NoSQL : 어떠한 형식에 데이터가 들어와도 다 받아들일수 있는, 수집하는데에만 목적이 있는 DB ex) MONGODB

## 7.4 데이터베이스 및 테이블 생성하기
* SQL도 쿼리 언어이므로 언어를 알아야함
### 데이터베이스 생성 
* CREATE SCHEMA [데이터베이스 명]
* MySql에서 SCHEMA(스키마)와 데이터베이스와 같은 개념임 
* ex) CREATE SCHEMA `nodejs` DEFAULT CHARACTER SET utf8; // 뒤에 구문은 한글을 사용할 수 있게해주는 구문
* ;(세미콜론) 끝에 붙여주기

* 참고) CREATE SCHEMA같이 MySQL이 기본적으로 알고있는 구문을 예약어라고 함
    * 예약어는 대 소문자 상관없지만 대문자로 적는게 좋음 -> 사용자가 직접 만든 이름과 구분하기 위해
### 테이블 생성
* 테이블 : 데이터가 들어갈 수 있는 틀, 테이블에 맞는 데이터만 들어 갈 수 있음 ex) 댓글 정보 테이블 등
* CREATE TABLE [데이터베이스명. 테이블명] : 데이터베이스안에 테이블을 생성하는 명령어
* 컬럼 생성 : [컬럼명] [자료형] [옵션] ex) id INT NOT NULL AUTO_INCREMENT 
    * ,(콤마)로 구분해 컬럼을 만듬 
    * 컬럼 이름 옆에는 자료형을 명시함
        * INT : 정수 / FLOAT, DOUBLE : 소수까지 
        * VARCHAR(자릿수) : 길이가 0~자릿수인 문자열 넣을 수 있음
        * CHAR(자릿수) : 길이가 자릿수인 문자열만 들어갈 수 있음
        * TEXT : 수백자이상의 긴 문자열 저장할때 사용
        * TINYINT : -128~127까지의 정수를 저장할 때 사용,  불값 표현할때 주로 씀
        * DATETIME : 날짜와 시간에 대한 정보 담음 / DATE : 날짜 정보만 담음 / TIME : 시간 정보만 담음
    * 컬럼 옵션 
        * NULL / NOT NULL : 빈칸 허용 여부
        * AUTO_INCREMENT : 1부터 자동 증가 옵션 ex) id에 AUTO_INCREMENT옵션 사용하면 처음 데이터에는 1 부여 하고 새로운 데이터 넣으면 자동으로 데이터에 2 부여 ...
        * UNSIGNED : 숫자 자료형에 적용하는 옵션으로 음수 무시하고 0~양수 범위만
        * ZEROFILL : 숫자의 자릿수가 고정되어 있을 때 사용 가능, 비어있는 자리에 0넣음 , INT(N)과 같은 자료형에 사용
        * DEFAULT  : 사용자가 안넣으면 기본적으로 넣는 값  
        * PRIMARY KEY(컬럼명) : 기본키 지정
            * 기본키 : 로우를 대표하는 고유한 값, 즉 로우를 구별하는 고유한 식별자
            * 겹칠가능성이 없는 고유한 값이어야 함
        * 외래키 
            * 다른 테이블의 기본키를 저장하는 컬럼
            * 외래키 저장방법 : CONSTRAINT [제약 조건 명] FOREIGN KEY [컬럼명] REFERENCES [참고하는 컬럼명] 
            * ex) CONSTRAINT commenter FOREIGN KEY (commenter) REFERENCES nodejs.users(id)
        * INDEX : 자주검색할거 같은거 index걸어주면 검색성능이 빨라짐
            * INDEX 인덱스명 (인덱싱할컬럼명 인덱싱방법) ex) INDEX commenter_idx (commenter ASC) 
        * UNIQUE : 해당 값이 고유해야하는지에 대한 옵션
            * 새로운 등록을하면서 UNIQUE면 기존 값이 있는 지 검색하는 과정 요구되므로 인덱싱함(INDEX 붙임)
            * ex) UNIQUE INDEX name_UNIQUE (name ASC)
        * ON UPDATE / ON DELETE : 업데이트 또는 삭제시 옵션
            * CASCADE : 사용자의 정보가 수정, 또는 삭제되면 그것과 연결된 정보도 같이 수정하거나 삭제, 데이터 불일치 현상 방지
            * SET NULL : 연결된 정보는 남겨두고 사용자 정보만 NULL로 남김, NO ACTION : 그냥유지 
            * 다음을 정책에 따라 잘 설정
    * COMMENT : 테이블에 대한 보충 설명 
    * DEFAULT CHARACTER SET= utf8 : 한글 입력하기위해 사용
* DESC 테이블명 : 만들어진 테이블 확인
* DROP TABLE 테이블명 : 테이블 제거
* SHOW TABLES : 생성된 테이블들 확인
* 대댓글 구현법 : 댓글에 다넣고 대댓글은 부모댓글의 id넣어준 후 프론트에서 처리 

## 7.5 CRUD 작업하기
### CRUD란?
* Create, Read, Update, Delete의 첫 글자를 모은 두 문자어로 데이터베이스에서 많이 수행하는 4가지 작업
* 이 방법만 익혀도 웬만한 프로그램은 다 만들 수 있을정도로 CRUD 작업은 많이 사용됨
### Create(생성)
* 데이터를 생성해서 데이터베이스에 넣는 작업
* INSERT INTO 테이블명 ([컬럼1],[컬럼2]...) VALUES ([값1],[값2]...)명령어로 수행
* ex) INSERT INTO nodejs.comments(commenter,comment) VALUES (1, '안녕하세요. zero의 댓글입니다');

### Read(조회)
* 데이터베이스에 있는 데이터를 조회하는 작업
* SELECT* FROM [테이블명] : users 테이블의 모든 데이터를 조회하는 sql문
* SELECT [컬럼1],[컬럼2].. FROM [테이블명] : 특정 컬럼들만 조회
* WHERE절을 사용해 특정 조건을 가진 데이터만 조회가능
    * AND로 여러 조건을 묶을수도 있고 OR로 어느 하나라도 만족하는 데이터 찾을 수 있음
    * ex) SELECT name, age FROM nodejs.users WHERE married=1 AND age>30; //결혼을 했고 나이가 30세이상인 사용자의 name,age 조회
* ORDER BY [컬럼명] [ASC|DSC] 키워드를 이용해 정렬도 가능 
    * ex) SELECT id, name FROM nodejs.users ORDER BY age DESC;//나이가 많은 순서대로 정렬    
* LIMIT [숫자] 키워드를 사용해 조회할 로우 개수 설정도 가능
    * ex) SELECT id, name FROM nodejs.users ORDER BY age DESC LIMIT 1;// 로우 하나만 조회
* OFFSET [건너뛸 숫자] : 처음 건너뛸 숫자만큼의 데이터를 건너뛰고 그 다음 게시물부터 조회

### Update(수정)
* 데이터베이스의 데이터를 수정하는 작업
* UPDATE [테이블 명] SET [컬럼명=바꿀 값] WHERE [조건] 
    * ex) UPDATE nodejs.users SET comment='바꿀 내용' WHERE id=2;

### Delete(삭제)
* 데이터베이스에 있는 데이터를 삭제하는 작업
* DELETE FROM [테이블 명] WHERE [조건] 
    * ex) DELETE FROM nodejs.users WHERE id=2;

    
## 7.6 시퀄라이즈(sequelize) 사용하기
* 시퀄라이즈(Sequelize) : 노드에서 SQL 작업을 쉽게 할 수 있도록 도와주는 라이브러리
    * 자바스크립트 코드만 쓰면 그 코드로 데이터베이스(SQL) 조작 가능
    * ORM(object relational mapping)(자바스크립트 객체와 데이텅베이스를 릴레이션 매핑해주는 도구)으로 분류됨
* npm으로 sequelize , sequelize-cli, mysql2 패키지 설치
    * sequelize-cli : 시퀄라이즈 명령어를 실행하기 위한 패키지
    * mysql2 : MySQL과 시퀄라이즈를 이어주는 드라이버
* 설치 완료후 sequelize init 명령어를 호출 : npx sequelize init
    * config, models, migration, seeders 폴더가 생성됨
* sequelize-cli가 자동으로 생성해주는 코드는 에러 자주 발생하고 필요없는 부분 많으므로 수정해줌
    * models/index.js 수정
    ```
    const Sequelize = require('sequelize');

    const env = process.env.NODE_ENV || 'development';
    const config = require(__dirname + '/../config/config.json')[env];
    const db = {};

    const sequelize=new Sequelize(config.database, config.username, config.password,config);
    db.sequelize=sequelize;

    module.exports = db;
    ```
    * Sequelize는 시퀄라이즈 패키지이자 생성자
    * config/config.json에서 데이터베이스 설정 불러온 후 new Sequelize를 통해 MySQL 연결 객체를 생성
    * 연결 객체를 나중에 재사용하기 위해 db.sequelize에 넣어둠
    * mysql ,node, sequelize를 서로 연결해주는 코드
### MySQL 연결하기
* 시퀄라이즈를 통해 익스프레스 앱과 MySQL 연결함
* 익스프레스와 시퀄라이즈 연결코드 
```javascript:app.js
const express =require('express');
const path=require('path');
const morgan = require('morgan');
const nunjucks=require('nunjucks');

const {sequelize} =require('./models');
//require('./models/index.js')와 동일 : 폴더 내에 index.js파일을 require시 이름 생략 가능

const app = express();
app.set('port',process.env.PORT||3001);
app.set('view engine','html');
nunjucks.configure('views',{
    express:app,
    watch:true,
});
sequelize.sync({force:false})
.then(()=>{
    console.log('데이터베이스 연결 성공');
})
.catch((err)=>{
    console.log(err);
});

app.use(morgan('dev'));
app.use(express.static(path.join(__dirname,'public')));
app.use(express.json());
app.use(express.urlencoded({extended:false}));

app.use((req,res,next)=>{
    const error=new Error(`${req.method} ${req.url}라우터가 없습니다`);
    error.status(error);
    next(error);
});
app.use((err,req,res,next)=>{
    res.locals.message=err.message;
    res.locals.error=process.env.NODE_ENV!=='production'?err:{};
    res.status(err.status||500);
    res.render('error');
});

app.listen(app.get('port'),()=>{
    console.log(app.get('port'),'번 포트에서 대기 중');
});
```
* db.sequelize를 불러와 sync메서드를 사용해 서버 실행 시 MySQL과 연동되게 함
    * force 옵션 : true 면 서버 실행 시마다 테이블을 재생성, 테이블을 잘못 만든 경우 true로 설정

* MySQL과 연동할 때는 config 폴더 안의 config.json 정보가 사용됨
    * config.json의 development.password, developement.database 부분을 현재 MySQL 커넥션과 일치하게 수정
    * test, production 부분은 각각 테스트 용도와 배포 용도로 사용
    * proceess.env.NODE_ENV에 따라 development, test, production 중 하나 적용됨(기본값은 development)

* 참고) Executing (default): SELECT 1+1 AS result -> SQL 하나를 MySQL에 실행시켜서 연결잘됐는지 검사하는 것, 이것이 실행 잘됐으면 연결 성공한것

### 시퀄라이즈 모델 정의하기
* 테이블을 만드는 방법 : 워크 벤치, cmd , 모델을 통해 만드는것
* 시퀄라이즈의 모델은 MySQL의 테이블과 대응되는데 시퀄라이즈가 모델과 MySQL의 테이블 연결하는 역할 함
* 모델은 공식문서의 형식을 따라 생성함
* ex) User 모델을 만들고 모듈로 exports함
```javascript
const Sequelize=require('sequelize');

module.exports=class User extends Sequelize.Model{
    static init(sequelize){
        return super.init({
            name:{
                type:Sequelize.STRING(20),
                allowNull:false,
                unique:true,
            },
            age:{
                type:Sequelize.INTEGER.UNSIGNED,
                allowNull:false,
            },
            married:{
                type:Sequelize.INTEGER.UNSIGNED,
                allowNull:false,
            },
            comment:{
                type:Sequelize.TEXT,
                allowNull:true,
            },
            created_at:{
                type:Sequelize.DATE,
                allowNull:false,
                defaultValue:Sequelize.NOW,
            },
        },{
            sequelize,
            timestamps:false,
            underscored:false,
            modelName:'User',
            tableName:'users',
            paranoid:false,
            charset:'utf8',
            collate:'utf8_general_ci',
        });
    }
    static associate(db){}
};
``` 
* 모델은 Sequelize.Model을 확장한 클래스로 선언
* 모델은 크게 static init과 static associate 메서드로 나눔
    * init 
        * 테이블에 대한 설정을 함
        * 첫번째 인수 : 테이블 컬럼에 대한 설정
        * 시퀄라이즈는 알아서 id를 기본키로 연결하므로 id 컬럼은 적어줄 필요 없음
        * 나머지 컬럼의 스펙을 입력하며, MySQL 테이블과 컬럼 내용이 일치해야 정확히 대응됨
        * 시퀄라이즈에서 자료형과 옵션
            * VARCHAR -> STRING
            * INT -> INTEGER
            * UNSIGNED INT -> INTEGER.UNSIGNED
            * UNSIGNED INT ZEROFILL -> INTEGER.UNSIGNED.ZEROFILL
            * TINYINT -> BOOLEAN 
            * DATETIME -> DATE 
            * NOT NULL -> allowNull 옵션
            * UNIQUE -> unique 옵션
            * DEFAULT -> defaultValue 
            * now() -> Sequelize.NOW
        * 두번째 인수 : 테이블 자체에 대한 옵션
            * sequlize : static init 메서드의 매개변수와 연결되는 옵션으로 db.sequelize 객체를 넣어야 함, 나중에 model/index.js에서 연결함
            * timestamps : 현재 false로 되어 있으며 ,이 속성 값이 true면 시퀄라이즈는 createdAt과 updatedAt컬럼을 추가하여 각각 로우가 생성, 수정 될 때의 시간을 자동으로 입력함
            * underscored : 시퀄라이즈는 기본적으로 테이블명과 컬럼명을 캐멀 케이스(camel case)로 만드는데 이를 스네이크 케이스 (snake case)로 바꾸는 옵션(ex) createdAt -> created_at)
            * modelName : 모델이름 설정, 노드 프로젝트에서 사용
            * tableName : 실제 데이터베이스 테이블의 이름, 기본적으로 모델이름을 소문자 및 복수형으로 만듦 ex)User -> users
            * paranoid : true로 설정하면 deletedAt이라는 컬럼이 생김, 로우 삭제 시 완전히 지워지지 않고 deletedAt에 지운 시각이 기록됨, 로우 조회 시 deletedAt의 값이 null인 로우를 조회, 나중에 로우 복원을 하기위해 사용 (ex) 회원정보 복원)
            * charset과 collate : 각각 utf8과 utf8_general_ci로 설정해야 한글 입력, 이모티콘까지 입력하려면 utf8mb4와 urf8mb4_general_ci로 입력
    * associate : 다른 모델과의 관계를 적음    
        * 시퀄라이즈 자체에서 관계를 따로 정의 가능
* 모델을 다 생성했으면 models/index.js와 연결함
```javascript
const Sequelize = require('sequelize');//클래스
const User = require('./user');
const Comment = require('./comment');

const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

const sequelize=new Sequelize(config.database, config.username, config.password,config);
db.sequelize=sequelize;

db.User=User;
db.Comment=Comment;

User.init(sequelize);
Comment.init(sequelize);

User.associate(db);
Comment.associate(db);

module.exports = db;//db 객체에 User와 Comment 모델를 담아 exports함

```
### 관계 
* 테이블 간의 관계의 종류 : 1:N(ex) 사용자 한명은 댓글 여러개) , 1:1 (ex) 사용자와 사용자의 정보 테이블), N:M (ex) 게시글 테이블과 해시태그 테이블 관계 (한 게시글에는 여러개의 해시태그, 한 해시태그도 여러 게시글에 달릴 수 있음))
* MySQL에서 JOIN기능으로 관계 파악해 결과 도출하지만 시퀄라이즈는 JOIN기능도 알아서 구현 
* 대신 테이블 간에 어떠한 관계가 있는지 시퀄라이즈에 알려야함
### 시퀄라이즈로 관계정의하기
1. 1:N
* hasMany라는 메서드로 표현
    * ex) db.User.hasMany(db.Comment,{foreignKey:'commenter',sourceKey:'id'});
    * 이러면 users 테이블의 로우 하나를 불러올 때 연결된 comments 테이블의 로우들도 같이 불러올 수 있음
* 반대로 belongsTo 메서드로 표현 
    * ex) db.Comment.belongsTo(db.User,{foreignKey:'commenter',targetKey:'id'});
    * comments테이블의 로우를 불러올 때 연결된 users 테이블의 로우를 가져옴
    * 다른 모델의 정보가 들어가는 테이블에 belongsTo 사용
* hasMany면 sourceKey , belongsTo면 targetKey
* foreignKey를 따로 지정하지않으면 모델명+기본키인 컬럼이 모델에 생성됨 ex) user(모델명)+id(기본키) -> userid 생성
2. 1:1 
* hasMany대신 hasOne사용
* 1:1 관계라해도 hasOne과 belongsTo가 반대로 되면 안됨(컬럼이 반대로 추가될 수 있음)
* ex) 사용자 정보를 담고있는 info 모델이 있다하면 
    * db.User.hasOne(db.Info,{foreignKey : 'UserId',sourceKey:'id'});
    * db.Info.belongsTo(db.User,{foreignKey:'UserId',targetKey:'id'});
3. N:M
* belongsTomMany메서드 사용
* ex) 가상의 Post모델과 해시태그 정보를 담고 있는 가상의 HashTag모델이 존재
    * db.Post.belongsToMany(db.Hashtag,{through:'PostHashtag'});
    * db.HashTag.belongsToMany(db.Post,{through:'PostHashtag'});
* N:M 관계 특성상 자동으로 새로운 모델이 생성되는데 through 속성에 그 모델명 적으면 됨
* 그 모델에는 각각 모델의 id가 저장됨

* 참고) 한 컬럼에는 하나의 데이터만 저장하는게 정규화 원칙임(배열도 안됨)

### 시퀄라이즈 쿼리 알아보기 
* 시퀄라이즈로 CRUD 작업하려면 SQL문을 자바스크립트로 생성하는 시퀄라이즈 쿼리를 알아야함
* 쿼리는 프로미스를 반환하므로 then이나 await 사용해줘야 함

* 로우 생성 쿼리(Create)
    * ex) SQL문 : INSERT INTO nodejs.users(name, age, married, comment) VALUES ('zero',24,0,'자기소개1');
    * 시퀄라이즈 쿼리로 변환
    ```javascript
    const {User} = require('../models');
    User.create({
        name:'zero',
        age: 24,
        married:false,
        comment : '자기소개1',
    });
    ```
    * 데이터를 넣을 때는 MySQL의 자료형이아닌 시퀄라이즈 모델에서 정의한 자료형으로 넣어줘야 함
    * 자료형이나 옵션에 부합하지 않는 데이터를 넣으면 시퀄라이즈가 에러 발생시킴

* 로우 조회 쿼리 (Read)
    * ex) SQL문 : SELECT* FROM nodejs.users;
    * 시퀄라이즈 쿼리로 변환 : User.findAll({}); // 모든 데이터를 가져올때는 findAll 메서드 이용
    
    * ex2) SQL문 : SELECT * FROM nodejs.users LIMIT 1;
    * 시퀄라이즈 쿼리로 변환 : User.findOne({}); // 한 로우만 가져옴
    * 또는 : User.findAll({limit:1});//limit 옵션을 설정

    * ex3) SQL문 : SELECT name, married FROM nodejs.users;
    * 시퀄라이즈 쿼리로 변환 : attributes 옵션을 이용해 원하는 컬럼만 가져옴
    ```javascript
    User.findAll({
        attributes:['name','married'],
    });
    ```

    * ex4) SQL문 : SELECT name, age,FROM nodejs.users WHERE married=1 AND age>30;
    * 시퀄라이즈 쿼리로 변환 
        * MySQL에선 undefined 지원하지 않으므로 빈 값은 null로 사용하기
        * Sequelize 객체 내부의 Op객체를 불러와 연산자들 사용함
            * Op.gt : 초과 / Op.lt : 미만
            * Op.gte : 이상 / Op.lte : 이하
            * Op.ne : 같지 않음
            * Op.or : 또는 
            * Op.in : 배열 요소 중 하나 
            * Op.notIn : 배열 요소와 모두 다름
            ```javascript
            const {Op} = require('sequelize');
            const {User} = require('../models');
            User.findAll({
                attributes:['name','age'],
                where:{
                    married:true,
                    age:{[Op.gt]:30},
                }
            });
            ``` 
    * ex5) SQL문 : SELECT id, name FROM users WHERE married = 0 OR age>30;
    * 시퀄라이즈 쿼리로 변환       
    ```javascript
        const {Op} = require('sequelize');
        const {User} = require('../models');
        User.findAll({
            attributes:['id','name'],
            where:{
            [Op.or] : [{married:false},{age:{[Op.gt]:30}}],//조건 나열
            },
        });
     ``` 

    * ex6) SQL 문 : SELECT id, name FROM users ORDER BY age DESC
    * 시퀄라이즈 쿼리로 변환 : 시퀄라이즈로 정렬, order 옵션은 배열안에 배열이 있는 구조(정렬 조건 여러개의 컬럼으로 할 수도 있음)
    ```javascript
    User.find({
        attributes : ['id','name'],
        order:[['age','DESC']],
    })
    ```

    * ex7) SQL 문 : SELECT id, name FROM users ORDER BY age DESC LIMIT 1 OFFSET;
    * 변환 : OFFSET도 offset 옵션으로 구현
    ```javascript
    User.findAll({
        attributes : ['id','name'],
        order : ['age','DESC'],
        limit : 1,
        offset : 1,
    });
    ```
* 로우 갱신 쿼리 (Update)
    * ex) SQL 문 : UPDATE nodejs.users SET comment ='바꿀 내용' WHERE id=2;
    * 변환 : 첫번째 인수로는 수정할 내용 , 두 번째 인수는 어떤 로우를 수정할지에 대한 조건(where이용)
    ```javascript
    User.update({
        comment:'바꿀 내용',
    },{
        where:{id:2},
    })
    ```

* 로우 삭제 쿼리 (Delete)
    * DELETE FROM nodejs.users WHERE id=2;
    * 변환 : User.destroy ({where : {id : 2},});


### 시퀄라이즈 관계 쿼리
* findOne이나 findAll 메서드를 호출할 때 프로미스의 결과로 모델(또는 모델의 배열을 반환) 을 반환함?
* 시퀄라이즈는 MySQL의 JOIN 기능인 관계 쿼리도 지원함

* ex1) User 모델과 Comment 모델이 hasMany-belongsTo 관계로 맺어져 있는 상태에서 특정 사용자를 가져오면서 그사람의 댓글까지 가져오고 싶을 때
    * include 속성을 사용
    ```javascript
    const user = await User.findOne({
        include:[{
            model: Comment,
        }]
    });
    console.log(user.Comments);
    // user.comments로 댓글에 접근 가능
    // hasmany면 복수로(Comments), hasone이면 단수(Comment)로 갖고 옴
    ```
    * get+모델명(조회)메서드로 가져올 수도 있음
    ```javascript
    const user =await User.findOne({});
    const comments =await user.getComments();
    console.log(comments);
    ```
* get+모델명 외에도 set+모델명(수정) , add+모델명(생성(단수면 하나생성 복수면 여러 개 생성)), remove+모델명(삭제) 메서드 존재
* 동사 뒤에 모델 이름을 바꾸려면 관계 설정 시 as 옵션 사용하면 되지만 선호하지 않음 
```
db.User.hasMany(db.Comment,{foreignKey:'commenter',sourceKey:'id',as:'Answers'});
const user=await User.findOne({});
const comments =await user.getAnswers();
```

* include나 관계 쿼리 메서드에도 where나 attributes 같은 옵션 사용 가능
```javascript
const user = await User.findOne({
    include:[{
        model:Comment,
        where:{
            id : 1,
        },
        attributes:['id'],
    }]
});
// 또는
const comments =await user.getComments({
    where:{
        id:1,
    },
    attributes:['id'],
})
```
* 조회와 다르게 수정, 생성, 삭제는 여러 개를 배열로 수정, 생성, 삭제 가능

```javascript
const user = await User.findOne({});
const comment1 = await Comment.create();
const comment2 = await Comment.create();
await user.addComment([comment1,comment2]);
```

### SQL 쿼리하기
* 직접 SQL문을 통해 쿼리하는 방법
```javascript
const [result,metadata]=await sequelize.query('SELECT *from comments');
console.log(result);
```

## 쿼리 실습
* 참고) 1대다의 관계에선 다부터 지우기
* 