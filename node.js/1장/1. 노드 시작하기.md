# 1. 노드 시작하기
## 노드 기본 
* Node.js : Chrome V8 javascript엔진으로 빌드된 javascript 런타임
* 노드를 통해 다양한 자바스크립트 앱을 실행할 수 있지만 서버 앱을 실행하는데 가장 많이 사용
### 서버란?
* 서버  
    * 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램
    * 웹, 앱 사용시 개인의 데이터(아이디, 패스워드 등)와 서비스의 데이터가 생성되는데 이 데이터를 저장하고 클라이언트에게 전달하는 역할함
    * 응답에 대해 거부도 가능
* 클라이언트 
    * 요청을 보내는 주체
    * 브라우저, 데스크톱 프로그램, 모바일 앱, 다른 서버에 요청을 보내는 서버 등이 될 수 있음    
* 클라이언트에서 요청을 하면 서버에서 응답을 보냄
    * ex) 브라우저에서 웹사이트 주소 입력(요청) -> 브라우저에서 그 주소에 해당하는 컴퓨터 위치 파악해 그 컴퓨터로 부터 페이지 받아와 브라우저에 띄움(응답)
    * ex) 앱 스토어에서 설치 버튼 누르면(요청) -> 내려받음 (응답)
### JS 런타임과 노드
* 런타임 : 특정 언어로 만든 프로그램들을 실행할 수 있는 환경
* 노드는 자바스크립트 런타임으로 노드를 통해 자바스크립트 프로그램 실행가능 함(자바 스크립트 실행기)
* 기존에는 자바스크립트는 JS가 내장된 웹 브라우저 위에서만 실행할 수 있었음
* 속도 문제를 해결하여 V8엔진을 이용한 노드 프로젝트 개발됨
* 노드는 V8(오픈 소스 자바스크립트 엔진)과 libuv라는 라이브러리 사용
* libuv는 노드의 특징인 이벤트 기반, 논 블로킹 I/O 모델 구현하고 있음


## 노드의 특징 
### 이벤트 기반(event-driven)
* 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식 의미
* 이벤트로는 클릭이나 네트워크 요청 등이 있음
* 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 함 -> 이벤트 리스너(event listener)에 callback 함수를 등록한다고 표현
* 노드도 이벤트 기반 방식이믈 이벤트가 발생하면 이벤트 리스너에 등록된 콜백함수를 호출함, 발생한 이벤트가 없거나 다 처리하고 나면 노드는 다음 이벤트가 발생할 때까지 대기한다

### 이벤트루프(event loop)와 순서
* 이벤트 루프(event loop) 
    * 여러 이벤트가 동시에 발생했을 때 순서 판단하는 루프, 호출 스택과는 다른 개념
    * 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할 담당
    * 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부름
    * 이벤트 루프는 태스크큐에 콜백함수가 들어오거나 노드가 종료될 때까지 계속 대기함
* 백그라운드 
    * setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳
    * 여러 작업이 동시에 실행될 수 있음

* 태스크 큐 
    * 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백함수를 보냄
    * 정해진 순서대로 콜백들이 줄을 서 있는 큐
    * 보통은 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀜
* 호출 스택이 비어있을때만 태스크 큐가 콜백들은 호출함수로 올리는데, 호출 스택에 너무 많은 함수가 들어 있으면 정해진 시간에 실행되지 않을 수도 있음

### non-blocking I/O
* 이벤트 루프를 잘 활용하면 오래걸리는 작업 효율적으로 처리 가능
* 자바스크립트 상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 노드에서 논 블로킹 방식을 통해 동시에 처리 가능 
* non-blocking 과 blocking 
    * non-blocking : 이전 작업이 완료될 때까지 대기하지 않고 다음 작업 수행
    * blocking : 이전 작업이 끝나야만 다음 작업을 수행
    * non-blocking 방식이 동시에 처리될 수 있는 작업들이 있다면 더 빠름
* setTimeout(콜백, 0) : non-blocking 방식으로 만드는 코드, 오래걸리는 작업 나중에 하고 싶을 때 사용 가능
* non-blocking 방식으로 코드를 작성해도 전부 한사람이 작성하고 실행한 코드면 소요 시간 짧아지진 않지만, 오래 걸리는 작업때문에 다른 작은 작업이 대기하는 상황 막을 수 있어 non-blocking 의미 있음
* non-blocking과 동시성
    * 같은의미가 아님
    * 동시성 : 동시 처리 가능한 작업을 non-blocking 처리해야 얻을 수 있음

### 싱글 스레드
* 프로세스와 스레드
    * 프로세스 : OS에서 할당하는 작업의 단위, 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스, 프로세스 간의 메모리 등의 자원 공유하지 않음
    * 스레드 : 프로세스 내에서 실행되는 흐름의 단위, 프로세스 내에서 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있음 부모 프로세스의 자원을 공유함, 서로 데이터 공유 가능
* 노드는 싱글 스레드
    * 노드를 실행하면 프로세스 하나 생성
    * 그 프로세스에서 스레드들을 여러 개 생성함
    * 이 중 직접 제어, 조작 할 수 있는 스레드는 하나뿐 
    * 따라서 싱글 스레드라 부름
* 요청이 많이 들어오면 한 번에 하나씩 요청을 처리함
* blocking이 심하게 일어나는 작업을 처리하지만 않는다면 싱글 스레드로도 충분함
* blocking 발생할 것 같은 경우에는 non-blocking 방법으로 대기 시간 최대한 줄임
* 싱글 스레드 non-blocking 모델은 효율적임을 보임
* ex) 싱글 스레드(점원)
    * 식당에서 점원이 손님에게 주문을 받음->주방에 넘김 -> 주방에서 요리나오면 서빙 -> 다음 손님 주문 받음 (싱글 스레드 blocking 방식)
    * 식당에서 점원이 손님에게 주문 받음 -> 주방에 주문 사실만 넘기고 주방에선 요리 시작-> 다음 손님 주문 받음 -> 요리 끝날때 까지 주문 받음 -> 요리 끝난 곳 부터 서빙(싱글 스레드 non-blocking 방식)
* 멀티 스레드 non-blocking 방식이 더 효율적이지만 구현이 매우 어려움 
* 대신 멀티 프로세싱 방식 사용
    * 여러 개의 프로세스 사용하는 방식
    * I/O 요청이 많을 때 사용 (I/O 요청이 많을 때는 멀티스레딩 보다 효율적)
    * 프로그래밍이 비교적 쉬움

### 서버로서의 노드의 장단점
* 노드는 non-blockin 방식으로 코드를 구성하면 libuv 라이브러리를 사용하여 I/O 작업을 논 블로킹 방식으로 처리함 -> 스레드 하나가 많은 수의 I/O를 혼자서 감당 가능
* CPU부하가 큰 작업에는 적합하지 않음 -> 코드가 많은 CPU연산을 요구하면 스레드 하나가 혼자서 감당하기 어려움
* 따라서, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는데 적합 -> 네트워크나 DB, 디스크 작업 같은 I/O에 특화 됨
* 실시간 채팅, 주식 차트, JSON데이터를 제공하는 API서버가 노드를 많이 사용함
* 노드 12버전에서 부터 멀티 스레드 작업 할 수 있게 되었지만, 싱글 스레드에 비해 매우 어렵고 다른 언어에 비해 멀티 스레드 매우 느림
* 이미지나 비디오 처리, 대규모 데이터 처리 처럼 CPU를 많이 사용하는 작업의 서버로는 권장하지 않음 
* AWS 람다나 구글 클라우드 펑션스 같은 서비스에서 노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원하므로 이를 이용해 CPU많이 사용하는 작업을 처리할순 있음
* 싱글 스레드 방식으로 서버를 운영할 때는 하나뿐이 스레드가 에러로 멈추지 않게 잘 관리해야 서버가 멈추지 않음
* 웹서버가 내장되어 있어 따로 웹 서버 설치 안해도 됨 (단, 서버 규모가 커지면 nginx 등의 웹 서버를 노드 서버와 연결해야만 함)
* 자바스크립트를 이용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발 할 수 있음 -> 개발 생산성 높아짐
* 생산성은 매우 좋지만 정적 파일 제공, 로드 밸런싱에 특화된 웹서버에 비해서는 속도가 느림 -> 극단적인 성능이 필요한 상황이 아니면 노드의 생산성으로 극복 가능 
* JSON 도 JS 형식이므로 노드로 쉽게 처리 가능
* 정리
    * 장점
        * 멀티 스레딩에 비해 적은 컴퓨터 자원 사용, 쉬움
        * I/O 작업이 많은 서버로 적합
        * 웹 서버 내장
        * 자바스크립트 사용함, JSON 형식과 쉽게 호환
    * 단점
        * 싱글 스레드라서 CPU 코어를 하나만 사용
        * CPU작업이 많은 서버로는 부적합
        * 하나의 스레드가 멈추지 않도록 관리 필요
        * 서버 규모가 커졌을 때 관리어려움
        * 어중간한 성능


### 서버외의 노드
* 웹, 모바일, 데스크톱 앱에도 사용하기 시작함
* 노드 기반 웹 프레임워크 : 앵귤러, 뷰, 리액트
* 앱 개발 도구 : 리액트 네이티브
* 데스크톱 개발도구 : 일랙트론 


### 객체 리터럴 
* ES5 시절의 객체 표현 방법
```
var sayNode=function(){
    console.log('node');
}
var es='ES';
var oldObject={
    sayJS:function(){
        console.log('JS');
    },
    sayNode:sayNode,
};
oldObject[es+6]='Fantastic';
oldObject.sayNode();
oldObject.sayJS();
console.log(oldObject.ES6);//Fantastic
```
* 현재
```
const newObject={
    sayJS(){//객체의 메소드에 함수를 연결할 때 :function 안 붙여도 됨
        console.log('JS');
    },
    sayNode,//속성명과 변수명이 동일한 경우에는 한번만 써도 됨
    [es+6]:'Fantastic',//객체 리터럴 ({})바깥에서 안하고 안에서 동적 선언해도 됨
};
newObject.sayNode();
newObject.sayJS();
console.log(newObject)
```

## 화살표 함수
* 기존의 function() {}도 그대로 사용하지만 화살표 함수(arrow function)이라는 새로운 함수 추가 됨
* 아래 add함수는 모두 같은 기능을 하는 함수
```
function add1(x,y){
    return x+y;
}

const add2=(x,y)=>{
    return x+y;
};//function선언 대신 =>이용

const add3=(x,y) => x+y;//내부의 리턴문 밖에없는 경우 중괄호 대신 return 할 식을 바로 적음
const add4=(x,y) =>(x+y);//보기 좋게 소괄호로 묶어도 됨

```