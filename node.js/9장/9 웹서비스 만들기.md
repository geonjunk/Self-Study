# 9. 익스프레스로 SNS 서비스 만들기 및 복습

- 로그인, 이미지 업로드, 게시글 작성, 게시글 작성, 해시태그 검색, 팔로잉 등의 기능이 있는 SNS NodeBird 앱 만들기

## 프로젝트 구조

- views : 템플릿 파일 넣을 폴더
- routes : 라우터를 넣을 폴더
- public : 정적 파일을 넣을 폴더
- passport : passport 패키지를 위한
- config, migration, models, seeders : sequelize 관련 폴더

## 기본 설계 및 DB 설정 + 여러 복습 및 필기

- npx 명령어 : 패키지를 실행시키는 명령어중 하나, npm 5.2.0 이상이 깔려있으면 실행가능
- express-session 옵션

  - resave : 요청이 올 때 세션에 수정사항이 생기지 않더라도 세션 다시 설정여부
  - saveUninitialized : 세션에 저장할 내역이 없더라도 처음부터 세션 생성여부
  - secret : 세션 쿠키를 서명하기 위한 값
  - cookie : 세션 쿠키의 옵션
  - name : 세션쿠키의 이름
  - store : 외부 저장소랑 연결할 때 사용하는 옵션

- 시퀄라이즈 설정을 담아둔 config.json에는 유일하게 하드 코딩된 비밀번호 남아있으며 JSON 파일이기 때문에 .env 사용도 불가능

  - 비밀번호 숨기는 법은 추후에 알아보기

- page.js설명

  - GET/profile , GET/join, GET/ 3개의 페이지로 구성
  - 템플릿 엔진에서 사용할 user, followingCount, followerCount, followerList 변수를 res.locals로 설정
    - res.locals로 설정하는 이유 : 모든 템플릿엔진에서 공통으로 사용하기 때문에

- DB 관계 설명
  - User와 Post -> 1:N관계
  - User와 User
    - N:M 관계
    - 팔로잉기능이 대표적 N:M 관계
    - 같은 테이블간의 N:M관계에서는 모델 이름과 컬럼 이름을 따로 정해야함
      - through 옵션을 통해 생성할 모델 이름 지정
      - 누가 following이고 follower인지 구분하기위해 foreignkey에는 userid로 그냥 넣지 않고 구분하여 설정함
      - as옵션 : 둘다 같은 모델이므로 구분하기 위해 foreignkey와 반대되는 모델을 가리킴, 현재 모델의 표현?
  - Post와 Hashtag
    - N:M관계
- 자동으로 생성된 모델도 쿼리 호출이나 관계 메서드 사용 가능함
  - ex) db.sequelize.models.PostHashtag
- DB 생성 : npx sequelize db:create 로 생성

## passport 모듈로 회원가입 구현하기

- 회원가입과 로그인은 직접 구현할 수 있지만 세션과 쿠키 처리등 복잡한 작업이 많으므로 검증된 모듈을 사용하는 것을 권장 -> passport 모듈 사용
- SNS 로그인도 passport 모듈로 구현 가능함
- passport 관련 패키지 : passport, passport-local, passport-kakao....
- passport모듈 app.js와 연결
  - require(`./passport`)은 require(`./passport/index.js`) 와 같은 뜻으로 app.js에 import 해준다
  - passport.initialize() 미들웨어 : req(요청 객체)를 passport 설정에 심음
  - passport.session() 미들웨어 : req.session 객체에 passport 정보를 저장함, req.session은 express-session에서 생성하기 때문에 passport 미들웨어는 express-session보다 뒤에 위치해야 함

### passport/index.js의 구조

- passport.serializeUser, passport.deserializeUser가 핵심
- serializeUser
  - 로그인 시 실행되며, req.session 객체에 어떤데이터를 저장할지 정하는 메서드
  - 매개변수로 user를 받고 나서, done 함수에 두번째 인수로 user.id를 넘김
  - user 객체에는 사용자 정보가 들어있음
  - done함수의 첫번째 인수는 에러발생 시 사용하는 것
  - 두 번째 인수에는 session에 저장하고 싶은 데이터를 넣어줌
    - 세션에 사용자 정보를 모두 저장하면 세션의 용량이 커지고 데이터 일관성 문제가 발생할 수 있어 아이디만 주로 저장함
- deserializeUser
  - 매 요청 시 실행됨(모든 페이지 접근 시에)
  - passport.session 미들웨어가 이 메서드 호출함
  - serialize의 done의 두번쨰 인수로 넣었던 데이터가 deserializeUser의 매개변수가 됨
  - 세션에 저장했던 id를 이용해 데이터베이스에 조회하여 조회한 정보 req.user에 저장함
- 즉, serializeUser는 사용자 정보객체를 세션에 저장, deserializeUser는 세션에 저장한 아이디를 통해 사용자 정보객체를 불러오는 것 -> 이는 세션에 불필요한 데이터를 담아두지 않기 위한 과정

### 전체 과정

- 라우터를 통해 로그인 요청들어옴
- 라우터에서 passport.authenticate 메서드 호출
- 로그인 전략 수행
- 로그인 성공 시 사용자 정보객체와 함께 req.login 호출
- req.login이 passport.serializeUser 호출
- req.session에 사용자 아이디만 저장
- 로그인 완료

- 로그인 이후
  - 요청이 들어옴
  - 라우터에 요청이 도달하기 전에 passport.session 미들웨어가 passport.deserializeUser 메서드 호출
  - req.session에 저장된 아이디로 데이터베이스에서 사용자 조회
  - 조회된 사용자 정보를 req.user에 저장

### 로컬로그인 구현

- 미들웨어

  - req.isAuthenticated 메서드를 이용해 로그인한 경우 또는 로그아웃 경우만 해당 라우터에 접근할 수 있도록 미들웨어 만들어줌

  ```javascript
  exports.isLoggedIn = (req, res, next) => {
    if (req.isAuthentiacated()) {
      next();
    } else {
      res.status(403).send("로그인 필요");
    }
  };

  exports.isNotLoggedIn = (req, res, next) => {
    if (!req.isAuthentiacated()) {
      next();
    } else {
      const message = encodeURIComponent("로그인한 상태입니다.");
      res.redirect("/?error=${message}");
    }
  };
  ```

- 회원가입, 로그인, 로그아웃 라우터

```javascript
const express = require(`express`);
const passport = require(`passport`);
const bcrypt = require(`bcrypt`);
const { isLoggedIn, isLoggedIn, isNotLoggedIn } = require(`./middlewares`);
const User = require(`../models/user`);

const router = express.Router();

router.post(`/join`, isNotLoggedIn, async (req, res, next) => {
  const { email, nick, password } = req.body;
  try {
    const exUser = await User.findOne({ where: { email } });
    if (exUser) {
      return res.redirect("/join?error=exist");
    }
    const hash = await bcrypt.hash(password, 12);
    await User.create({
      email,
      nick,
      password: hash,
    });
    return res.redirect("/");
  } catch (error) {
    console.error(error);
    return next(error);
  }
}); // 회원가입 라우터

router.post("/login", isNotLoggedIn, (req, res, next) => {
  passport.authenticate("local", (authError, user, info) => {
    //로컬 로그인 전략 실행
    if (authError) {
      console.error(authError);
      return next(authError);
    }
    if (!user) {
      return res.redirect(`/loginError=${info.message}`);
    }
    return req.logIn(user, (loginError) => {
      //성공하면 req.login 호출함, req.login은 passport.serializeUser 호출
      if (loginError) {
        console.error(loginError);
        return next(loginError);
      }
      return res.redirect("/");
    });
  })(req, res, next); // 미들웨어 내의 미들웨어에는 (req,res,next)를 붙임
});

router.post("/logout", isLoggedIn, (req, res) => {
  //req.user객체 제거, req.session을 제거함
  req.logout();
  req.session.destroy();
  res.redirect("/");
});

module.exports = router;
```

- 로컬 로그인 전략

  - LocalStrategy 생성자를 이용해 전략을 구현
  - done을 통해 해당 결과를 passport.authenticate('local')로 보냄

  ```javascript
  const passport = require(`passport`);
  const LocalStrategy = require(`passport-local`).Strategy;
  const bcrypt = require(`bcrypt`);

  const User = require(`../models/user`);
  module.exports = () => {
    passport.use(
      new LocalStrategy(
        {
          usernameField: "email",
          passwordField: "password",
        },
        async (email, password, done) => {
          try {
            const exUser = await User.findOne({ where: { email } });
            if (exUser) {
              const result = await bcrypt.compare(password, exUser.password);
              if (result) {
                done(null, exUser);
              } else {
                done(null, false, { message: "비밀번호가 일치하지 않습니다" });
              }
            } else {
              done(null, false, { message: "가입되지않은 회원입니다" });
            }
          } catch (error) {
            console.error(error);
            done(error);
          }
        }
      )
    );
  };
  ```
